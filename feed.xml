<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://humanlee1011.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://humanlee1011.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-19T01:43:40+00:00</updated><id>https://humanlee1011.github.io/feed.xml</id><title type="html">Xiaoyun Li</title><subtitle>Xiaoyun Li&apos;s blog </subtitle><entry><title type="html">在Mac上用VSCode敲LaTeX</title><link href="https://humanlee1011.github.io/others/2019/02/25/MacTex.html" rel="alternate" type="text/html" title="在Mac上用VSCode敲LaTeX"/><published>2019-02-25T19:00:00+00:00</published><updated>2019-02-25T19:00:00+00:00</updated><id>https://humanlee1011.github.io/others/2019/02/25/MacTex</id><content type="html" xml:base="https://humanlee1011.github.io/others/2019/02/25/MacTex.html"><![CDATA[<h1 id="在mac上用vscode敲latex">在Mac上用VSCode敲LaTeX</h1> <p>一开始我是使用内网搭建的shareLaTeX，如果状态好的时候也可以用这个来写完一篇论文（第一篇论文就是在shareLaTeX上面完成的），但是因为实验室网络以及服务器的不稳定，我觉得现在得放弃用shareLaTeX来编写论文了。上次就因为运维sharelatex的人在赶作业= =也不好意思麻烦别人来维护，差点就丢失了论文数据，还好最后重新搭一遍找到了我的论文。</p> <p>既然科研要深入，还是一次性配置好这个LaTeX，免得以后再来做这种琐碎的小事。</p> <h2 id="电脑环境">电脑环境</h2> <p>Mac OS Mojave版本10.14.3 VS code版本1.30.2</p> <h2 id="安装latex">安装LaTeX</h2> <p>LaTeX安装教程特别多，而且安装文件特别大，MacTex整套装下来有3.42GB，MacTeX包含了一些GUI界面，有另一种BasicTeX不包括GUI的，仅有70MB+，有兴趣的可以尝试。为避免不必要的麻烦，我还是选择安装MacTeX。有两种安装方法：</p> <ul> <li><a href="http://www.tug.org/mactex/">MacTeX官网</a></li> <li>homebrew安装。</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">brew</span> <span class="n">cask</span> <span class="n">install</span> <span class="n">basictex</span>
</code></pre></div></div> <p>安装好之后应用程序folder会出现TeX文件夹： <img src="/asset/img/post_img/2019-02-25/Tex-folder.png" alt="tex-folder"/> <img src="/asset/img/post_img/2019-02-25/tex-folder-contents.png" alt="tex-folder-content"/></p> <ul> <li>BibDesk 是用来管理参考文献的，这个对于第一次写论文的人来说是一个大项目，但是一旦做完了以后引用文献就很方便了。</li> <li>TeXShop 是可以用来编辑LaTeX</li> <li>TeX Live Utility是管理LaTeX宏包的GUI界面</li> </ul> <h2 id="在vscode中配置latex">在VScode中配置LaTeX</h2> <p>在VSCode中点选左侧扩展按钮，在展开的扩展栏顶端搜索 LaTeX Workshop，搜到后点击安装。（该扩展是当前编译 LaTeX 的全部依赖，微软官方的LaTeX Language Support已经停止开发。）</p> <p>重启vscode，然后，打开vscode的配置界面(快捷键<code class="language-plaintext highlighter-rouge">cmd+,</code>)，需要修改下面两项配置。</p> <ul> <li>在<code class="language-plaintext highlighter-rouge">latex-workshop.latex.tools</code>配置中，增加xelatex项，具体如下。这一项的作用是在工具集中定义xelatex项，以便下一项配置能找到</li> <li>在<code class="language-plaintext highlighter-rouge">latex-workshop.latex.recipes</code>配置中，将第一项的latexmk改为xelatex。这里定义的是编译时调用的工具顺序，默认第一个为latexmk，因为我们要支持中文，所以替换为xelatex。</li> </ul> <pre><code class="language-JSON">{
    "latex-workshop.latex.tools": [
        {
            "name": "xelatex",
            "command": "xelatex",
            "args": [
                "-synctex=1",
                "-interaction=nonstopmode",
                "-file-line-error",
                "-pdf",
                "%DOC%"
            ]
        },
        {
            "name": "latexmk",
            "command": "latexmk",
            "args": [
                "-synctex=1",
                "-interaction=nonstopmode",
                "-file-line-error",
                "-pdf",
                "%DOC%"
            ]
        },
        {
            "name": "pdflatex",
            "command": "pdflatex",
            "args": [
                "-synctex=1",
                "-interaction=nonstopmode",
                "-file-line-error",
                "%DOC%"
            ]
        },
        {
            "name": "bibtex",
            "command": "bibtex",
            "args": [
                "%DOCFILE%"
            ]
        }
    ],
    "latex-workshop.latex.recipes": [
        {
              "name": "xelatex -&gt; bibtex -&gt; xelatex*2", //如果带有BibTeX，要编译三次
              "tools": [
                  "xelatex",
                  "bibtex",
                  "xelatex"
              ]
          },
        {
            "name": "pdflatex -&gt; bibtex -&gt; pdflatex*2",
            "tools": [
                "pdflatex",
                "bibtex",
                "pdflatex",
                "pdflatex"
            ]
        }
    ]
}
</code></pre> <h2 id="安装宏包">安装宏包</h2> <p>在配置完VScode之后，还需要另外装宏包来支持编译。用<code class="language-plaintext highlighter-rouge">tlmgr</code>管理比较方便.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tlmgr</span> <span class="n">install</span> <span class="err">宏包</span>
</code></pre></div></div> <h2 id="后记">后记</h2> <h3 id="配置问题">配置问题</h3> <p>在安装的过程中，一直卡在了setting.json的配置上面，网上有多种配置教程。官网有一个推荐的override setting，但是使用那个后会出现以下错误：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logger[4155]    This is pdfTeX, Version 3.1415926-1.40.11 (TeX Live 2010)
logger[4155]    restricted \write18 enabled.
logger[4155]    entering extended mode
logger[4155]    ! I can't write on file `test.log'.
logger[4155]    (Press Enter to retry, or Control-D to exit; default file extension is `.log')
logger[4155]    Please type another transcript file name
logger[4155]    ! Emergency stop
</code></pre></div></div> <p>这个错误大致意思是没有写入权限。但是我在文件夹单独编译<code class="language-plaintext highlighter-rouge">.tex</code>文件又不会报出这种错误，所以应该是要定义好正确的写入路径，和原<code class="language-plaintext highlighter-rouge">.tex</code>在同一目录下。在tools的args参数中要定义好%DOC%，马上就成功了。</p> <h3 id="字体">字体</h3> <p>我之前是采用了IEEEtran的模版，但是编译出来字体一直不正确，会报出下面的错误：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LaTeX Font Warning: Font shape `TU/ptm/m/n' undefined
(Font)              using `TU/lmr/m/n' instead on input line 503.
</code></pre></div></div> <p>xelatex不支持里面的font，难怪看起来特别丑= =</p> <p>解决方法是在<code class="language-plaintext highlighter-rouge">/documentclass[conference]{IEEEtran}</code>后面加上<code class="language-plaintext highlighter-rouge">\usepackage[OT1]{fontenc} </code>，这个包可以补充font，再编译就成功了。</p> <h2 id="ref">ref:</h2> <ol> <li> <p><a href="https://medium.com/@rcpassos/writing-latex-documents-in-visual-studio-code-with-latex-workshop-d9af6a6b2815">Writing LaTeX Documents In Visual Studio Code With LaTeX Workshop</a></p> </li> <li> <p><a href="https://zhuanlan.zhihu.com/p/38178015">使用VSCode编写LaTeX</a></p> </li> </ol>]]></content><author><name>Leexy</name></author><category term="others"/><category term="工具"/><category term="经验分享"/><summary type="html"><![CDATA[在Mac上用VSCode敲LaTeX]]></summary></entry><entry><title type="html">NLP学习</title><link href="https://humanlee1011.github.io/learn/2019/02/25/NLP.html" rel="alternate" type="text/html" title="NLP学习"/><published>2019-02-25T19:00:00+00:00</published><updated>2019-02-25T19:00:00+00:00</updated><id>https://humanlee1011.github.io/learn/2019/02/25/NLP</id><content type="html" xml:base="https://humanlee1011.github.io/learn/2019/02/25/NLP.html"><![CDATA[<h1 id="神经网络">神经网络</h1> <h2 id="梯度下降">梯度下降</h2> <p>使用误差方程来计算预测值和真实值的差距，不断调整神经网络中连接的权重。</p> <p>主要是通过梯度下降的方法来找到局部最优的权重值。</p> <h2 id="补充">补充</h2> <h3 id="one-hot编码">one-hot编码</h3> <ol> <li>为什么要binarize分类特征？使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。</li> <li>Why do we embed the feature vectors in the Euclidean space?是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在<font color="#dd0000">欧式空间的相似度计算，计算余弦相似性</font>，基于的就是欧式空间。</li> <li>将离散型特征进行one-hot编码的作用，是为了让距离计算更合理，但如果特征是离散的，并且不用one-hot编码就可以很合理的计算出距离，那么就没必要进行one-hot编码，比如，该离散特征共有1000个取值，我们分成两组，分别是400和600,两个小组之间的距离有合适的定义，组内的距离也有合适的定义，那就没必要用one-hot 编码。</li> </ol> <h2 id="word2vec">word2vec</h2> <p>在此之前，nlp是将字词转为one-hot编码类型的词向量。缺点在于，数据稀疏性非常高，维度很多，容易造成维度灾难。存在语义鸿沟，无法体现词与词之间的关系。</p> <p>神经网络的训练是有监督的学习，因此要给定输入值和输出值来训练神经网络，而我们最终要获得的是隐藏层的权重矩阵。因为隐藏层的输出事实上是每个输入单词的 “嵌入词向量”。计算的时候，并不会进行矩阵乘法，而是直接找1所在的地方，直接读取词向量。 <img src="https://images2018.cnblogs.com/blog/1335117/201807/1335117-20180719103717765-785211295.png" alt="image"/></p> <h2 id="rnn">RNN</h2> <p>是受到人的思考方式的启发，当人看到一个句子时，对单词的理解是基于对上一个单词的认知，因此这个序列关系/上下文关系对单词的理解很有帮助。 RNN是一个具有有限loop的神经网络，如下图所示，$x_t$为输入，$h_t$为输出，$A$是RNN网络结构。 <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-rolled.png" width="20%" height="20%" halign="center"/></p> <p>将上面这个loop展开后可以看到： <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="unrolled"/></p> <p>RNN的优点：</p> <ol> <li>chain-like的网络结构可以让lists和sequences之间的关系得到学习。</li> <li>可应用于以下方面：speech recognition, language modeling, translation, image captioning… The list goes on.</li> </ol> <h2 id="lstm">LSTM</h2> <p>LSTM是一种特殊的RNN，大多数运用RNN成功的例子都是基于LSTM完成的。 RNN能够通过上下文的关系来预测，但是如果上下文距离很遥远，RNN是无法预测的，比如“I grew up in France… I speak fluent <em>French</em>.”。此处<em>French</em>需要France的relevant information，但是两个单词位于不同的句子中，距离非常遥远。</p> <ul> <li>为什么RNN无法预测？ 在理论上，RNN可以通过configure参数来扩大读取的面积，但是在实际中，RNN并不能handle这种预测，因为depth过深，时间上是无法完成。</li> </ul> <p>相较于RNN，LSTM不同的是在网络结构中，有多种interacting way <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png" alt="LSTM"/></p> <h3 id="lstm的core-idea">LSTM的core idea</h3> <p>LSTM具有三种gates，通过sigmoid函数[0,1]来可计算component通过的概率，以此来protect和control这些cell state</p> <p>具体步骤：</p> <ol> <li>forget gate layer，用一个$f_t$来forget掉我们希望忘记的previous subject的info<img src="https://images2018.cnblogs.com/blog/1335117/201807/1335117-20180724213408875-497357476.png" alt="input"/></li> <li>input gate layer，用于决定我们要更新==哪一个值==，创建一个new candidate values$C_t$介入state。<img src="https://images2018.cnblogs.com/blog/1335117/201807/1335117-20180724213929491-1697948414.png" alt="input"/></li> <li>output gate layer, Then we add $i_t * C̃<em>t$，然后和前面已遗忘的$C</em>{t-1}$state相加，$C_t = f_t * C_{t-1} + i_t * C̃_t$<img src="https://images2018.cnblogs.com/blog/1335117/201807/1335117-20180724214355115-204684729.png" alt="input"/></li> </ol> <p>接下来看神经元内最上方的$C{t−1}$.与$a{t−1}$类似，Ct−1也携带着上文的信息。进入神经元后，Ct−1首先会与遗忘权重逐元素相乘，可以想见，由于遗忘权重中值得特点，因此与该权重相乘之后Ct−1​ 中绝大部分的值会变的非常接近0或者非常接近该位置上原来的值。这非常像一扇门，它会决定让哪些Ct−1的元素通过以及通过的比例有多大。反映到实际中，就是对Ct−1中携带的信息进行选择性的遗忘（乘以非常接近0的数）和通过（乘以非常接近1的数），亦即乘以一个权重。</p> <p>理解了遗忘门的作用之后，其他两个门也就比较好理解了。输入门则是对输入信息进行限制，而输入信息就是RNN中的前向运算的结果。经过输入门处理后的信息就可以添加到经过遗忘门处理的上文信息中去，这就是神经元内唯一一个逐元素相加的工作。</p> <h3 id="lstm的variants">LSTM的variants</h3> <ol> <li>将$C_{t-1}$拼接到$h_{t-1}, x_t$后面。</li> </ol> <h2 id="attention机制">Attention机制</h2> <p>注意力模型，这个说到底还只是一个资源分配模型，在某个特定时刻，你的注意力总是集中在画面中的某个焦点部分，而对其它部分视而不见。</p> <h3 id="encoder-decoder框架">Encoder-Decoder框架</h3> <p>Encoder-Decoder模型中的<strong>编码</strong>，就是将输入序列转化成一个固定长度的向量；<strong>解码</strong>，就是将之前生成的固定向量再转化成输出序列。 <img src="https://images2018.cnblogs.com/blog/1335117/201807/1335117-20180725165549037-254698930.png" alt="Encoder-Decoder"/></p> <p>缺点：在编码时，后输入的语义信息会覆盖前面输入的语义信息，导致Encoder得到的编码C是有损信息。因而，在解码时，解析的数据本身就不够准确。</p> <p>为了解决上面的弊端，就需要用到Attention Model。在编码时，让code <code class="language-plaintext highlighter-rouge">C</code>拥有一个注意力范围。</p> <h3 id="注意力分配概率分布值">注意力分配概率分布值</h3> <p><img src="https://images2018.cnblogs.com/blog/1335117/201807/1335117-20180725173624266-1186701597.png" alt=""/> 可以采用</p> <p>\(c_i = \sum _{j=1}^{T_x}{\alpha_{ij}h_{j}}\) 其中： \(\alpha_{ij} = \frac{exp(e_{ij})}{\sum_{k=1}^{T_x}{exp(e_{ik})}}\) \(e_{ij} = a(s_{i-1}, h_j)\)</p> <p>在上面公式中 $h_j$是Encoder层的隐层第j时刻的输出，$s_{i−1}$是Decoder层第$i−1$时刻隐层的输出。可以发现在计算 $c_i$的模型实际上是一个线性模型，而且$c_i$事实上是Encoder层中各时刻隐层的输出的加权平均值。</p> <p>因此引入Attention 机制，在机器翻译中，模型会自己去学得在不同时刻不同的权重系数$a_{ij}$</p> <h2 id="bi-lstm">Bi-LSTM</h2> <h2 id="参考">参考</h2> <ol> <li>http://colah.github.io/posts/2015-08-Understanding-LSTMs/</li> <li>https://www.cnblogs.com/jiangxinyang/p/9362922.html</li> <li>https://www.cnblogs.com/jiangxinyang/p/9362922.html</li> <li>https://www.cnblogs.com/jiangxinyang/p/9367497.html</li> </ol>]]></content><author><name>Leexy</name></author><category term="learn"/><category term="经验分享"/><summary type="html"><![CDATA[神经网络 梯度下降 使用误差方程来计算预测值和真实值的差距，不断调整神经网络中连接的权重。]]></summary></entry><entry><title type="html">Jmeter测试详记</title><link href="https://humanlee1011.github.io/testing/2018/07/07/Jmeter%E6%B5%8B%E8%AF%95%E8%AF%A6%E8%AE%B0.html" rel="alternate" type="text/html" title="Jmeter测试详记"/><published>2018-07-07T18:00:00+00:00</published><updated>2018-07-07T18:00:00+00:00</updated><id>https://humanlee1011.github.io/testing/2018/07/07/Jmeter%E6%B5%8B%E8%AF%95%E8%AF%A6%E8%AE%B0</id><content type="html" xml:base="https://humanlee1011.github.io/testing/2018/07/07/Jmeter%E6%B5%8B%E8%AF%95%E8%AF%A6%E8%AE%B0.html"><![CDATA[<blockquote> <p>对于系分的小型项目，决定在用mocha做完单元测试的基础上，再用Jemter进行压力测试。Jmeter是比较简单的压力测试工具，只需配置一些参数，即可生成一份性能报告。</p> </blockquote> <p>首先 右键Test Plan，Add-&gt;Threads(User)-&gt;Threads Group 新增线程组</p> <h3 id="http-默认设置">http 默认设置</h3> <p>右键Threads Group，Add-&gt;Config Element-&gt;HTTP Request Defaults. 在http 默认设置中先设置好我们需要测试的server地址，因为我们的网站是基于https，所以在protocol处填写https，端口号填写443 <img src="/asset/img/post_img/2018-07-07-Test/http_request_defaults.png" alt="HTTP request DEFAULTS"/></p> <h3 id="http-header-设置">http header 设置</h3> <p>右键Threads Group，Add-&gt;Config Element-&gt;HTTP Header Manager.因为很多API中要求Post data的格式是application/json，因此需要另外设置<code class="language-plaintext highlighter-rouge">Content-Type</code>。</p> <p><img src="/asset/img/post_img/2018-07-07-Test/http_header.png" alt="HTTP HHEADER "/></p> <h3 id="http-cookie-manager设置">http cookie manager设置</h3> <p>右键Threads Group，Add-&gt;Config Element-&gt;HTTP Cookie Manager.在许多项目中，都会涉及登录账号的操作，因此，就需要一个cookie管理器来保存登录账户的cookie。添加http cookie manager，它就会帮你自动保存账户的cookie，所以再来完成其他操作时就会自动在http header添加cookie字段。 <img src="/asset/img/post_img/2018-07-07-Test/http_cookie_manager.png" alt="http cookie"/></p> <h3 id="http-request-设置">http request 设置</h3> <p>右键Test Plan-&gt;Add-&gt;Sampler-&gt;HTTP Request,根据你测试的接口修改method和url，这里的protocol，server，port number已经在http request default中设置后，所以不用再另外设置了。</p> <p><img src="/asset/img/post_img/2018-07-07-Test/http_request.png" alt="http request"/></p> <h3 id="参数化">参数化</h3> <ul> <li> <p>在parameters中传递参数，以name-value的形式输入，如下图输入就会生成<code class="language-plaintext highlighter-rouge">/restaurant/self/order?page=0&amp;number=10&amp;state=accepted,paid,created&amp;keyword=1</code>的请求url <img src="/asset/img/post_img/2018-07-07-Test/query_order.png" alt="parameters"/></p> </li> <li> <p>在body data中传递数据，body data默认传递<code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code>的格式 <img src="/asset/img/post_img/2018-07-07-Test/body_data.png" alt="body data"/></p> </li> </ul> <h3 id="线程组设置">线程组设置</h3> <p>接下来要讲的是性能测试的核心——线程组。线程组可以规定x个线程（用户）并发执行测试计划中的操作，通过设定Ramp-Up，可以设定在x秒后执行下一组操作。</p> <h3 id="测试结果">测试结果</h3> <ul> <li> <p>每一个测试用例的结果</p> <p>在线程组右键 Add-&gt;Listener-&gt;View Result Trees,添加<code class="language-plaintext highlighter-rouge">察看结果树</code>就可以查看每一个测试用例的request、response数据，便于分析接口是否运行正确。 <img src="/asset/img/post_img/2018-07-07-Test/get_dish_result.png" alt="result tree"/> <img src="/asset/img/post_img/2018-07-07-Test/get_dish_result2.png" alt="result tree"/></p> </li> <li> <p>聚合报告</p> <p>在线程组右键 Add-&gt;Listener-&gt;Aggregate Report,添加<code class="language-plaintext highlighter-rouge">聚合报告</code>，在聚合报告中，Jmeter会返回多项参数，其中包括：</p> <ul> <li>Label：JMeter的每个HTTP Request的name属性值</li> <li>Samples：请求数，表示本次测试一共发出了多少个请求</li> <li>Average：单个HTTP Request的平均响应时间</li> <li>Median：50%用户的响应时间</li> <li>90% Line：90%用户的响应时间</li> <li>95% Line：95%用户的响应时间</li> <li>99% Line：99%用户的响应时间</li> <li>Min：最小响应时间</li> <li>Max：最大响应时间</li> <li>Error%：错误率，即错误请求数 / 请求总数</li> <li>Throughtput：吞吐量，每秒完成的请求数</li> <li>Received KB/Sec：每秒从服务器端接收到的数据量</li> <li>Sent KB/Sec：每秒发送到服务器端的数据量</li> </ul> </li> </ul> <p><img src="/asset/img/post_img/2018-07-07-Test/并发5.png" alt="result"/></p> <p>我们可以从聚合报告中得到某个url的响应速度，进而分析服务器的性能。</p> <h3 id="总结">总结</h3> <p>Jmeter总体来说是一个非常轻量级的工具，它可以完成简单的压力测试，是小型项目测试的利器。这次因为时间有限还没有挖掘更多的新功能如导入csv文件执行多项测试，多个用户并发测试等等。新手上路，若文中有错，请多多指点。</p>]]></content><author><name>Leexy</name></author><category term="testing"/><category term="后端"/><category term="数据库"/><category term="Jmeter"/><category term="软件测试"/><summary type="html"><![CDATA[对于系分的小型项目，决定在用mocha做完单元测试的基础上，再用Jemter进行压力测试。Jmeter是比较简单的压力测试工具，只需配置一些参数，即可生成一份性能报告。 首先 右键Test Plan，Add-&gt;Threads(User)-&gt;Threads Group 新增线程组 http 默认设置 右键Threads Group，Add-&gt;Config Element-&gt;HTTP Request Defaults. 在http 默认设置中先设置好我们需要测试的server地址，因为我们的网站是基于https，所以在protocol处填写https，端口号填写443 http header 设置 右键Threads Group，Add-&gt;Config Element-&gt;HTTP Header Manager.因为很多API中要求Post data的格式是application/json，因此需要另外设置Content-Type。 http cookie manager设置 右键Threads Group，Add-&gt;Config Element-&gt;HTTP Cookie Manager.在许多项目中，都会涉及登录账号的操作，因此，就需要一个cookie管理器来保存登录账户的cookie。添加http cookie manager，它就会帮你自动保存账户的cookie，所以再来完成其他操作时就会自动在http header添加cookie字段。 http request 设置 右键Test Plan-&gt;Add-&gt;Sampler-&gt;HTTP Request,根据你测试的接口修改method和url，这里的protocol，server，port number已经在http request default中设置后，所以不用再另外设置了。 参数化 在parameters中传递参数，以name-value的形式输入，如下图输入就会生成/restaurant/self/order?page=0&amp;number=10&amp;state=accepted,paid,created&amp;keyword=1的请求url 在body data中传递数据，body data默认传递application/x-www-form-urlencoded的格式 线程组设置 接下来要讲的是性能测试的核心——线程组。线程组可以规定x个线程（用户）并发执行测试计划中的操作，通过设定Ramp-Up，可以设定在x秒后执行下一组操作。 测试结果 每一个测试用例的结果 在线程组右键 Add-&gt;Listener-&gt;View Result Trees,添加察看结果树就可以查看每一个测试用例的request、response数据，便于分析接口是否运行正确。 聚合报告 在线程组右键 Add-&gt;Listener-&gt;Aggregate Report,添加聚合报告，在聚合报告中，Jmeter会返回多项参数，其中包括： Label：JMeter的每个HTTP Request的name属性值 Samples：请求数，表示本次测试一共发出了多少个请求 Average：单个HTTP Request的平均响应时间 Median：50%用户的响应时间 90% Line：90%用户的响应时间 95% Line：95%用户的响应时间 99% Line：99%用户的响应时间 Min：最小响应时间 Max：最大响应时间 Error%：错误率，即错误请求数 / 请求总数 Throughtput：吞吐量，每秒完成的请求数 Received KB/Sec：每秒从服务器端接收到的数据量 Sent KB/Sec：每秒发送到服务器端的数据量 我们可以从聚合报告中得到某个url的响应速度，进而分析服务器的性能。 总结 Jmeter总体来说是一个非常轻量级的工具，它可以完成简单的压力测试，是小型项目测试的利器。这次因为时间有限还没有挖掘更多的新功能如导入csv文件执行多项测试，多个用户并发测试等等。新手上路，若文中有错，请多多指点。]]></summary></entry><entry><title type="html">系分-Lesson16</title><link href="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/30/Lesson16.html" rel="alternate" type="text/html" title="系分-Lesson16"/><published>2018-06-30T18:00:00+00:00</published><updated>2018-06-30T18:00:00+00:00</updated><id>https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/30/Lesson16</id><content type="html" xml:base="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/30/Lesson16.html"><![CDATA[<h3 id="1-使用bce实现用例的详细设计">1. 使用BCE实现用例的详细设计</h3> <p>使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图）</p> <h4 id="用例简介">用例简介</h4> <p>make reservation的用例图如下： <img src="/asset/img/post_img/2018-04-18-Lesson6/hotel_use_case.png" alt="use case"/></p> <p>主用例为make reservation</p> <p>子用例包括choose hotel，choose room type, confirm reservation</p> <h4 id="make-reservation-顺序图">make reservation 顺序图</h4> <p><img src="/asset/img/post_img/2018-06-30-Lesson16/make_reservation_sequence.png" alt="sequence"/></p> <h4 id="make-reservation-类图">make reservation 类图</h4> <p><img src="/asset/img/post_img/2018-06-30-Lesson16/make_reservation_class.png" alt="class"/></p> <h3 id="2-框架映射">2. 框架映射</h3> <p>将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类。 <img src="/asset/img/post_img/2018-06-30-Lesson16/mapping.png" alt="mapping"/></p>]]></content><author><name>Leexy</name></author><category term="系分"/><category term="系统分析与设计"/><category term="详细分析"/><summary type="html"><![CDATA[1. 使用BCE实现用例的详细设计]]></summary></entry><entry><title type="html">系分项目个人总结</title><link href="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/30/%E7%B3%BB%E5%88%86%E9%A1%B9%E7%9B%AE%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="系分项目个人总结"/><published>2018-06-30T18:00:00+00:00</published><updated>2018-06-30T18:00:00+00:00</updated><id>https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/30/%E7%B3%BB%E5%88%86%E9%A1%B9%E7%9B%AE%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93</id><content type="html" xml:base="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/30/%E7%B3%BB%E5%88%86%E9%A1%B9%E7%9B%AE%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93.html"><![CDATA[<h3 id="项目">项目</h3> <p><a href="https://baoleme.github.io/Dashboard/">项目主页</a></p> <h3 id="自我总结">自我总结</h3> <p><code class="language-plaintext highlighter-rouge">15331169 @humanlee1011</code></p> <p>本次课程大作业，不仅运用到了系统分析设计的知识，也可以说是本科学习阶段成果的一个基本检验。而且团队开发让整个项目的量级变大，更像是一个真正的软件了。在完成这个项目时，我们不仅仅要考虑到如何优美的编写代码，也要考虑到如何合理地分析设计，这对于我未来完成其他项目时会有很大的帮助。团队合作、分析设计是我在这次项目中学习到最多的两个点，我们团队有7个人，也算是一个小型的团队了，在线下开会和线上讨论时其实会比人少的队伍更难达成共识。然而，组内分工明确，态度积极向上，大家努力将坑都一一填好。正是在这种积极的氛围下，我们的团队合作非常好，这也算是大学以来完成最愉快，学习最多的一次项目了。</p> <p>在这个项目里，我主要参与了分析设计部分的以及测试部分的工作，能够将两门课程的理论知识运用其中，收获颇丰。</p> <p>在这里也要非常感谢尽职尽责的PM，开发端的三位大佬，以及两位一起写文档、一起测试的大佬。大家都各司其职，完成得非常好。</p> <h3 id="psp21统计表">PSP2.1统计表</h3> <p><code class="language-plaintext highlighter-rouge">15331169 @humanlee1011</code></p> <table> <thead> <tr> <th>PSP阶段</th> <th>耗时(h)</th> </tr> </thead> <tbody> <tr> <td>计划</td> <td>2</td> </tr> <tr> <td>· 估计任务时间</td> <td>2</td> </tr> <tr> <td>开发</td> <td>60</td> </tr> <tr> <td>· 分析需求</td> <td>10</td> </tr> <tr> <td>· 生成设计文档</td> <td>20</td> </tr> <tr> <td>· 设计复审</td> <td>0</td> </tr> <tr> <td>· 代码规范</td> <td>0</td> </tr> <tr> <td>· 具体设计</td> <td>8</td> </tr> <tr> <td>· 具体编码</td> <td>0</td> </tr> <tr> <td>· 代码复审</td> <td>0</td> </tr> <tr> <td>· 测试</td> <td>22</td> </tr> <tr> <td>报告</td> <td>2</td> </tr> <tr> <td>·测试报告</td> <td>2</td> </tr> <tr> <td>·计算工作量</td> <td>0</td> </tr> <tr> <td>事后总结，提出过程改进计划</td> <td>2</td> </tr> <tr> <td><strong>合计</strong></td> <td>66</td> </tr> </tbody> </table> <h3 id="git统计报告">Git统计报告</h3> <p>DashBoard</p> <p><img src="/asset/img/post_img/2018-06-30-post/dashboard.png" alt="dashboard"/></p> <p>Server</p> <p><img src="/asset/img/post_img/2018-06-30-post/server.png" alt="server"/></p> <h3 id="劳苦清单">劳苦清单</h3> <p>需求分析，写文档，画图，测试</p> <h3 id="个人博客">个人博客</h3> <ul> <li><a href="https://humanlee1011.github.io/2018/04/14/usecase/">用例模型小结</a></li> </ul>]]></content><author><name>Leexy</name></author><category term="系分"/><category term="系分"/><category term="总结"/><summary type="html"><![CDATA[项目 项目主页]]></summary></entry><entry><title type="html">软件架构与框架</title><link href="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/03/Lesson13.html" rel="alternate" type="text/html" title="软件架构与框架"/><published>2018-06-03T18:00:00+00:00</published><updated>2018-06-03T18:00:00+00:00</updated><id>https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/03/Lesson13</id><content type="html" xml:base="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/06/03/Lesson13.html"><![CDATA[<h3 id="描述软件架构与框架之间的区别与联系">描述软件架构与框架之间的区别与联系</h3> <h4 id="软件架构architecture-style定义">软件架构（architecture style）定义</h4> <blockquote> <p>An architecture is the set of significant decisions about the organization of a software system, which describe the selection of the structural elements and their interfaces by which the system is composed，and their behavior as specified in the collaborations among those elements</p> </blockquote> <p>软件架构就是把系统分解为一些部件，描述这些部件的职责及它们之间的协作行为。</p> <h4 id="应用框架application-frameworks定义">应用框架（application frameworks）定义</h4> <p>框架是特定语言和技术的架构应用解决方案。例如 Java Spring web framework，它包含了 Java 开发 web应用的各种业务场景的具体解决方案。</p> <h4 id="区别">区别</h4> <ul> <li>软件架构不是软件，它不仅仅关注软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解、经济以及技术的限制和权衡等。</li> <li>软件框架是面向领域（如ERP、计算领域等）的、可复用的“半成品”软件，它实现了该领域的共性部分，并提供了一些定义良好的可变点以保证灵活性和可扩展性。通常是具体语言和技术相关的。</li> </ul> <h4 id="联系">联系</h4> <ul> <li>框架是一种或多种架构的组合的实现</li> </ul> <h3 id="以你的项目为案例">以你的项目为案例</h3> <ul> <li>绘制三层架构模型图，细致到分区 <img src="/asset/img/post_img/2018-06-03-Lesson13/style_diagram.png" alt="架构模型图"/></li> <li> <p>结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利</p> <ul> <li>每个层次内部模块的职责非常清晰，层次与层次之间的关系明确，减少耦合和依赖性</li> <li>为程序提高了代码的复用性</li> <li>可以让不同层的开发者专注于本层开发，减少其余不必要的培训、磨合时间，提高开发效率</li> <li>以我们的项目为例，三层的区分度明显，大大提高了开发的效率</li> </ul> </li> </ul> <h3 id="研究-vue-与-flux-状态管理的异同">研究 VUE 与 Flux 状态管理的异同</h3> <ul> <li> <p>同 由于状态零散地分布在许多组件和组件之间的交互中，大型应用复杂度也经常逐渐增长。Vue和Flux状态管理的目的都是为了解决大型应用中复杂冗余的数据交互。</p> </li> <li> <p>异：对数据流的管理方式不同</p> <ul> <li> <p>Flux 试图通过强制<strong>单向数据流</strong>来解决这个复杂度。在这种架构当中，Views 查询 Stores（而不是 Models），并且用户交互将会触发 Actions，Actions 则会被提交到一个集中的 Dispatcher 当中。当 Actions 被派发之后，Stores 将会随之更新自己并且通知 Views 进行修改。这些 Store 当中的修改会进一步促使 Views 查询新的数据。 <img src="https://user-gold-cdn.xitu.io/2016/11/29/2944d82baf02a5f02cde3db8056316f4.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"/></p> </li> <li> <p>Vuex</p> </li> </ul> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态 每一个Vuex应用就是一个store，在store中包含组件中的共享状态state和该改变状态的方法<strong>mutations</strong>，不同于Flux状态管理的Dispatcher。</p> <p><img src="https://segmentfault.com/img/remote/1460000007168704" alt="image"/></p> </li> </ul> <h3 id="参考">参考</h3> <ul> <li><a href="https://juejin.im/entry/577f06e62e958a0054af5a2a">什么是Flux？</a></li> <li><a href="https://zhuanlan.zhihu.com/p/20263396">图解Flux</a></li> </ul>]]></content><author><name>Leexy</name></author><category term="系分"/><category term="系统分析与设计"/><category term="软件架构"/><summary type="html"><![CDATA[描述软件架构与框架之间的区别与联系 软件架构（architecture style）定义 An architecture is the set of significant decisions about the organization of a software system, which describe the selection of the structural elements and their interfaces by which the system is composed，and their behavior as specified in the collaborations among those elements 软件架构就是把系统分解为一些部件，描述这些部件的职责及它们之间的协作行为。 应用框架（application frameworks）定义 框架是特定语言和技术的架构应用解决方案。例如 Java Spring web framework，它包含了 Java 开发 web应用的各种业务场景的具体解决方案。 区别 软件架构不是软件，它不仅仅关注软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解、经济以及技术的限制和权衡等。 软件框架是面向领域（如ERP、计算领域等）的、可复用的“半成品”软件，它实现了该领域的共性部分，并提供了一些定义良好的可变点以保证灵活性和可扩展性。通常是具体语言和技术相关的。 联系 框架是一种或多种架构的组合的实现 以你的项目为案例 绘制三层架构模型图，细致到分区 结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利 每个层次内部模块的职责非常清晰，层次与层次之间的关系明确，减少耦合和依赖性 为程序提高了代码的复用性 可以让不同层的开发者专注于本层开发，减少其余不必要的培训、磨合时间，提高开发效率 以我们的项目为例，三层的区分度明显，大大提高了开发的效率 研究 VUE 与 Flux 状态管理的异同 同 由于状态零散地分布在许多组件和组件之间的交互中，大型应用复杂度也经常逐渐增长。Vue和Flux状态管理的目的都是为了解决大型应用中复杂冗余的数据交互。 异：对数据流的管理方式不同 Flux 试图通过强制单向数据流来解决这个复杂度。在这种架构当中，Views 查询 Stores（而不是 Models），并且用户交互将会触发 Actions，Actions 则会被提交到一个集中的 Dispatcher 当中。当 Actions 被派发之后，Stores 将会随之更新自己并且通知 Views 进行修改。这些 Store 当中的修改会进一步促使 Views 查询新的数据。 Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态 每一个Vuex应用就是一个store，在store中包含组件中的共享状态state和该改变状态的方法mutations，不同于Flux状态管理的Dispatcher。 参考 什么是Flux？ 图解Flux]]></summary></entry><entry><title type="html">系分Lesson9</title><link href="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/05/13/Lesson9.html" rel="alternate" type="text/html" title="系分Lesson9"/><published>2018-05-13T18:00:00+00:00</published><updated>2018-05-13T18:00:00+00:00</updated><id>https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/05/13/Lesson9</id><content type="html" xml:base="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/05/13/Lesson9.html"><![CDATA[<p>根据<a href="https://github.com/gogogoSYSU/documents/blob/master/%E5%BB%BA%E6%A8%A1%E7%BB%83%E4%B9%A0/ofo%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E5%BA%94%E7%94%A8.pdf">业务文档</a>进行建模练习：</p> <h3 id="用例图">用例图</h3> <p><img src="/asset/img/post_img/2018-05-13-Lesson9/use_case_diagram.png" alt="use case"/></p> <h3 id="活动图">活动图</h3> <p><img src="/asset/img/post_img/2018-05-13-Lesson9/activity_diagram.png" alt="activity"/></p> <h3 id="ofo领域模型">ofo领域模型</h3> <p><img src="/asset/img/post_img/2018-05-13-Lesson9/domain.png" alt="domain"/></p> <h3 id="状态图">状态图</h3> <p>画出单车的状态转换图 <img src="/asset/img/post_img/2018-05-13-Lesson9/state.png" alt="state diagram"/></p> <h3 id="场景的系统顺序图与操作契约">场景的系统顺序图与操作契约</h3> <p>选取扫码-骑车这一场景简历系统顺序图</p> <p><img src="/asset/img/post_img/2018-05-13-Lesson9/seq.png" alt="sequence"/></p>]]></content><author><name>Leexy</name></author><category term="系分"/><category term="系统分析与设计"/><category term="建模练习"/><summary type="html"><![CDATA[根据业务文档进行建模练习： 用例图 活动图 ofo领域模型 状态图 画出单车的状态转换图 场景的系统顺序图与操作契约 选取扫码-骑车这一场景简历系统顺序图]]></summary></entry><entry><title type="html">系分Lesson8</title><link href="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/05/06/Lesson8.html" rel="alternate" type="text/html" title="系分Lesson8"/><published>2018-05-06T15:00:00+00:00</published><updated>2018-05-06T15:00:00+00:00</updated><id>https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/05/06/Lesson8</id><content type="html" xml:base="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/05/06/Lesson8.html"><![CDATA[<h3 id="1-使用uml-state-model">1) 使用UML State Model</h3> <ul> <li>建模对象：参考Asg_RH文档，对Reservation/Order对象建模</li> <li>建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。 <img src="/asset/img/post_img/2018-05-06-Lesson8/state_1.png" alt="state_diagram1"/></li> </ul> <h3 id="2研究淘宝退货流程活动图对退货业务对象状态建模">2）研究淘宝退货流程活动图，对退货业务对象状态建模</h3> <p>状态图: <img src="/asset/img/post_img/2018-05-06-Lesson8/state_2.png" alt="state_diagram2"/></p>]]></content><author><name>Leexy</name></author><category term="系分"/><category term="系统分析与设计"/><category term="状态建模"/><summary type="html"><![CDATA[1) 使用UML State Model 建模对象：参考Asg_RH文档，对Reservation/Order对象建模 建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。 2）研究淘宝退货流程活动图，对退货业务对象状态建模 状态图:]]></summary></entry><entry><title type="html">系分Lesson7</title><link href="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/04/30/Lesson7.html" rel="alternate" type="text/html" title="系分Lesson7"/><published>2018-04-30T19:00:00+00:00</published><updated>2018-04-30T19:00:00+00:00</updated><id>https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/04/30/Lesson7</id><content type="html" xml:base="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/04/30/Lesson7.html"><![CDATA[<h3 id="领域建模">领域建模</h3> <p>根据Asg_RH中的用例进行领域建模：</p> <h4 id="1-用例1搜索酒店">1. 用例1：搜索酒店</h4> <p><img src="/assets/img/post_img/2018-04-29-Lesson7/domain_model_1.png" alt="domain_model_1"/></p> <h4 id="2-用例2预约酒店">2. 用例2：预约酒店</h4> <p><img src="/assets/img/post_img/2018-04-29-Lesson7/domain_model_2.png" alt="domain_model_2"/></p> <h3 id="数据库逻辑模型">数据库逻辑模型</h3> <p>使用在线工具Vertabelo进行数据库建模</p> <p><img src="../asset/img/post_img/2018-04-29-Lesson7/Hotel_ER.png" alt="database model"/></p> <h3 id="简述领域建模和数据库建模的异同">简述领域建模和数据库建模的异同</h3> <h4 id="相同点">相同点</h4> <p>领域建模和数据库建模在展示的形式上非常相似，都是通过类，属性，关联构建的。</p> <h4 id="不同点">不同点</h4> <p>领域建模的重点在于将用例中的概念类逐一标出，找到他们之间的联系。而数据库逻辑模型是将概念类及其属性转换成将具体的数据存储类型，并将实体之间的联系转换为关系。</p>]]></content><author><name>Leexy</name></author><category term="系分"/><category term="系统分析与设计"/><category term="领域建模"/><category term="数据库模型"/><summary type="html"><![CDATA[领域建模 根据Asg_RH中的用例进行领域建模： 1. 用例1：搜索酒店 2. 用例2：预约酒店 数据库逻辑模型 使用在线工具Vertabelo进行数据库建模 简述领域建模和数据库建模的异同 相同点 领域建模和数据库建模在展示的形式上非常相似，都是通过类，属性，关联构建的。 不同点 领域建模的重点在于将用例中的概念类逐一标出，找到他们之间的联系。而数据库逻辑模型是将概念类及其属性转换成将具体的数据存储类型，并将实体之间的联系转换为关系。]]></summary></entry><entry><title type="html">系分Lesson6</title><link href="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/04/18/Lesson6.html" rel="alternate" type="text/html" title="系分Lesson6"/><published>2018-04-18T15:00:00+00:00</published><updated>2018-04-18T15:00:00+00:00</updated><id>https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/04/18/Lesson6</id><content type="html" xml:base="https://humanlee1011.github.io/%E7%B3%BB%E5%88%86/2018/04/18/Lesson6.html"><![CDATA[<h3 id="1-用例建模">1. 用例建模</h3> <ul> <li>a. 阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet。</li> </ul> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/post_img/2018-04-18-Lesson6/hotel_use_case-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/post_img/2018-04-18-Lesson6/hotel_use_case-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/post_img/2018-04-18-Lesson6/hotel_use_case-1400.webp"/> <img src="/assets/img/post_img/2018-04-18-Lesson6/hotel_use_case.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>b. 选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求： <ul> <li>对比 Asg_RH 用例图，用红色标注出创新用例</li> <li>尽可能识别外部系统，用黄色标注新的外部系统和服务</li> </ul> </li> </ul> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/qunar_use_case-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/qunar_use_case-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/qunar_use_case-1400.webp"/> <img src="/asset/img/post_img/2018-04-18-Lesson6/qunar_use_case.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>c. 对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法</li> </ul> - ASG_RH文档中的订酒店系统比较旧，将酒店预订、搜索酒店、支付等用保守的方式展现出来 - 去哪儿的订酒店系统，有几个创新点：点评问答、担保、到店付款。这几个创新点分别从旅客的角度和酒店的角度考虑，将酒店的信息公开化，既能保障旅客的利益也能为酒店揽客，达到双赢的局面。 - 在项目早期，突出一个注重的点很重要，切身地从使用者/Actor的角度思考，以最佳的方式设计用例。 <ul> <li>d. 请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog）</li> </ul> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/qunar_backlog-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/qunar_backlog-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/qunar_backlog-1400.webp"/> <img src="/asset/img/post_img/2018-04-18-Lesson6/qunar_backlog.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="2-业务建模">2. 业务建模</h3> <ul> <li>a. 在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。利用流程图发现子用例的方法： <ul> <li>流程图将某一个用例完整的业务流程描述出来，从一个状态转移到另一个状态的过程，通常伴随某些操作。</li> <li>在描述用例模型时，有可能会忽略某些情况。流程图可以帮助发现隐藏的子用例。</li> </ul> </li> <li>b. 选择你身边的银行 ATM，用活动图描绘取款业务流程</li> </ul> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/ATM_activity-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/ATM_activity-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/ATM_activity-1400.webp"/> <img src="/asset/img/post_img/2018-04-18-Lesson6/ATM_activity.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>c. 查找<a href="https://consumerservice.taobao.com/self-help#page=issue-detail&amp;knowledgeId=1119776">淘宝退货业务</a>官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例</li> </ul> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/taobao-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/taobao-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/asset/img/post_img/2018-04-18-Lesson6/taobao-1400.webp"/> <img src="/asset/img/post_img/2018-04-18-Lesson6/taobao.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="3-用例文本编写">3. 用例文本编写</h3> <p>在大作业基础上，分析三种用例文本的优点和缺点</p> <ul> <li>摘要文本</li> </ul> - 优点：用简洁的一段式概要，将主成功场景分析出来。有助于软件开发者快速理解软件的需求。 - 缺点：过于简洁，缺少子用例/扩展用例，缺少详细的描述，仅适用于早期的需求分析。 <ul> <li>非正式文本</li> </ul> - 优点：可以用非正式的几个段落覆盖不同场景。简单易懂。 - 缺点：缺少详细的描述，仅适用于早期的需求分析。 <ul> <li>详述文本</li> </ul> - 优点：详细编写所有步骤及各种变化，同时具有补充部分，比如前置条件和成功保证。 - 缺点：过于详细，不利于非软件开发者阅读，不利于快速理解用例。]]></content><author><name>Leexy</name></author><category term="系分"/><category term="系统分析与设计"/><category term="用例图"/><category term="活动图"/><summary type="html"><![CDATA[1. 用例建模]]></summary></entry></feed>